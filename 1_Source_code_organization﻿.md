# 소스 코드 구조

## 디렉토리 구조

순수한 코틀린 프로젝트에서, 권장되는 디렉토리 구조는 공통적인 루트 패키지가 생략된 패키지 구조를 따른다. 예를 들어, 만약 프로젝트 내의 모든 코드가 org.example.kotlin 패키지에 있고 해당 서브 패키지들에 있는 경우, org.example.kotlin 패키지가 있는 파일은 소스 루트 아래에 바로 위치해야 하고 org.example.kolin.network.socket의 파일은 소스 루트의 network/socket 서브 디렉토리에 있어야 한다. 

> JVM : 코틀린이 자바와 함께 프로젝트에서 사용되는 경우, 코틀린 소스 파일은 자바 소스 파일과 동일한 소스 루트 내에 있어야 하고 같은 디렉토리 구조를 따라야 한다. 각각의 파일은  각각의 패키지 문에 해당하는 디렉토리에 저장되어야 한다.
> 

## 소스 파일 이름

만약 코틀린 파일에 단일 클래스나 인터페이스 포함되어있을 경우(잠재적으로 최고 레벨 선언과 관련되어있다면), 그 이름은 .kt 확장자가 추가되어 클래스의 이름과 같아야 한다.이 규칙은 모든 종류의 클래스와 인터페이스에 적용된다. 만약 파일이 여러 개의 클래스나 오직 최고 레벨 선언만 포함할 경우, 파일이 담고 있는 내용을 설명하는 이름을 선택해야 한다. 예를 들어 ProcessDeclarations.kt처럼 upper camel case(Pascal case라고도 알려진)를 사용한다.

파일의 이름은 무슨 일을 하는지가 표현되어야 한다. 그러므로 파일 이름에 Util과 같이 의미없는 단어들을 사용하는 것을 피해야 한다. 

### 멀티플랫폼 프로젝트

멀티플랫폼 프로젝트에서 플랫폼별 소스 집합에서 최고 레벨 선언이 있는 파일들은 소스 집합의 이름과 관련된 접미사를 가져야 한다.

- **jvm**Main/kotlin/Platform.**jvm**.kt
- **android**Main/kotlin/Platform.**android**.kt
- **ios**Main/kotlin/Platform.**ios**.kt

공통 소스 집합에서, 최고 레벨 선언을 가진 파일들을 접미사를 가질 수 없다. 예를 들어, commonMain/kotlin/Platform.kt이다. 

## 소스 파일 구성

같은 코틀린 소스 파일에서 여러 개의 선언문(클래스, 최상위 함수나 프로퍼티) 배치하는 것은 가능한 이러한 선언들이 서로 의미론적으로 밀접한 관련이 있고 파일 사이즈가 합리적으로 유지되는 경우 권장된다. 

특히, 이 클래스의 모든 클라이언트와 관련있는 클래스에 대한 확장 함수를 정의할 때, 그것들을 클래스 자체와 동일한 파일에 두어라. 특정한 클라이언트에게만 의미가 있 확장 함수를 정의할 때, 해당 클라이언트의 코드 옆에 두어라. 일부 클래스의 모든 확장을 보유하기 위해 파일을 만들지 마라.

## 클래스 레이아웃

클래스 내용들은 다음 순서로 진행되어야 한다. 

1. 프로퍼티 선언과 초기화 블록
2. 보조생성자
3. 메서드 선언
4. 동반객체(Companion object)

메서드 선언을 알파벳 순이나 가시성을 기준으로 정렬하지 말고 확장 메서드와 일반 메서드를 구분하지 마라. 대신에, 관련된 것을 정리해서 클래스를 위에서부터 아래로 읽는 다른 사람들이 논리 구조를 이해할 수 있도록 해라. 순서(최고 레벨부터 시작할건지, 반대로 할건지)를 선택하고 그것을 따라라.

해당 클래스를 사용하는 코드 옆에 중첩된 코드를 두어라. 만약 클래스를 외부에서 사용하려고 하고 클래스 내부에서 참조하지 않는다면 마지막 companion object 뒤에 두어라, 

## 인터페이스 구현 레이아웃

인터페이스를 구현할 때, 구현 멤버를 인터페이스의 멤버와 같은 순서로 유지해라. (만약 필요하다면,  구현을 위해 추가적으로 private 메서드를 포함해라.)

## Overload 레이아웃

클래스에서 오버로드 된 메소드들은 항상 서로 가까운 곳에 위치하게 두어라.

